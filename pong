#!/usr/bin/env zsh

## env setup

# load mathfunc for rint
zmodload zsh/mathfunc

# for fancy scoreboard print
source libfancytext

# associative array for game arena (hashmap)
typeset -A pong

# alias integer to int for brevity
alias int=integer

# clear screen, hide cursor, set echo chars to false
clear
print "\033[?25l"
stty -echo
print "Loading..."

# define ints for scorekeeping
int pong_score_left pong_score_right score_space_count

# tile variables - set to defaults if not defined (must be UTF-8)
[ -z "$arena_tile" ] && {
  arena_tile='üü¶'
}

[ -z "$ball_tile" ] && {
  ball_tile='üê∏'
}

[ -z "$l_pad_tile" ] && {
  l_pad_tile='ü™µ'
}

[ -z "$r_pad_tile" ] && {
  r_pad_tile='üçÄ'
}

# if arena x length not set, invalid type, or <17, default to 17
([ -z "$arena_x" ] || ! [[ $arena_x =~ ^[0-9]+$ ]] || ((arena_x<17))) && {
  int arena_x=17
}

# if arena y length not set, invalid type, or <9, default to 9
([ -z "$arena_y" ] || ! [[ $arena_y =~ ^[0-9]+$ ]] || ((arena_y<9))) && {
  int arena_y=9
}

# if background colour not set, default to 4 (blue)
[ -z "$arena_bg" ] || \
! [[ $arena_bg =~ ^[0-7]+$ ]] && {
  int arena_bg=4
}

# calcuate how many spaces to place between display of p1 score and p2 score
score_space=''
((score_space_count=(rint(arena_x*0.65))))
for ((i=1; i<=score_space_count; i++)); do
  score_space=""$score_space" "
done

# define other needed ints
int arena_x_mid arena_y_mid paddletwo_start_x paddleone_start_x ball_x_pos ball_y_pos left_pad_x left_pad_y right_pad_x right_pad_y ball_was_east ball_was_west

# calculate arena mid + paddle start pos
((arena_x_mid=(arena_x-(arena_x/2))))
((arena_y_mid=(arena_y-(arena_y/2))))
((paddleone_start_x=2))
((paddletwo_start_x=(arena_x-1)))

## helper functions

# populate gameboard, set starting positions
pong_init_arena() {
  # randomization vals
  local randonum
  local randonum2
  local randonum3
  # populate grid with arena tiles
  for ((y_total=1; y_total<=arena_y; y_total++)); do
    for ((x_total=1; x_total<=arena_x; x_total++)); do
      pong[$x_total,$y_total]="$arena_tile"
    done
  done
  # add paddle + ball to arena
  pong[$arena_x_mid,$arena_y_mid]="$ball_tile"
  pong[$paddleone_start_x,$arena_y_mid]="$l_pad_tile"
  pong[$paddletwo_start_x,$arena_y_mid]="$r_pad_tile"
  # set initial paddle x y pos
  ((left_pad_x=paddleone_start_x))
  ((left_pad_y=arena_y_mid))
  ((right_pad_x=paddletwo_start_x))
  ((right_pad_y=arena_y_mid))
  # set initial ball x y pos
  ((ball_x_pos=arena_x_mid))
  ((ball_y_pos=arena_y_mid))
  # --- randomization of ball start pos ---
  # generate random num between 1-9
  ((randonum=((RANDOM%9)+1)))
  # if 1 2 or 3, shift start pos north
  ((randonum<=3)) && {
    pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
    ((ball_y_pos++))
    # generate random num between 0-9
    ((randonum2=(RANDOM%10)))
    # if greater than 4, shift again (50%)
    ((randonum2>4)) && {
      ((ball_y_pos++))
    }
    # generate random num between 0-9
    ((randonum3=(RANDOM%10)))
    # if greater than 7, shift again (20%)
    ((randonum3>7)) && {
      ((ball_y_pos++))
    }
    pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
  }
  # if 4 5 or 6, do nothing
  # if 7 8 or 9, shift start pos south
  ((randonum>6)) && {
    pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
    ((ball_y_pos--))
    # generate random num between 0-9
    ((randonum2=(RANDOM%10)))
    # if greater than 4, shift again (50/50)
    ((randonum2>4)) && {
      ((ball_y_pos--))
    }
    # generate random num between 0-9
    ((randonum3=(RANDOM%10)))
    # if greater than 7, shift again (20%)
    ((randonum3>7)) && {
      ((ball_y_pos--))
    }
    pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
  }
}

# prints contents of $pong as grid
print_pong_arr() {
  for ((y_count=1; y_count<=y_total; y_count++)); do
    for ((x_count=1; x_count<=x_total; x_count++)); do
      print -n $pong[$x_count,$y_count]
    done
    print
  done
}

# initial arena draw function
pong_draw() {
  # attain pong grid via print_pong_arr
  pong_buffer=$(print_pong_arr)
  # set colour based on $arena_bg (0-7)
  print "\033[4"$arena_bg"m"
  # return cursor to upper-left corner
  print "\033[H"
  # print contents of pong buffer (arena grid)
  print "$pong_buffer"
  # reset text formatting (clear bg colour)
  print "\033[0m"
  # rehide cursor since above command shows it
  print "\033[?25l"
  # scoreboard print:
  # ansi code '\033[F' moves cursor to beginning of
  # line since invisible ansi codes still have width
  print "\033[F"$(ctext cyan)"p1 score"$(ctext white)": "$pong_score_left""$score_space""$(ctext red)"p2 score"$(ctext white)": "$pong_score_right""$(ctext reset)""
  print ''
}

# establish initial ball direction
pong_rand_dir() {
  # indexed array containing all directions
  pong_dirs=('ne'
             'e'
             'se'
             'sw'
             'w'
             'nw')
  # generate random num between 1-7
  ((pong_rand_val=((RANDOM%6)+1)))
  # set ball direction to pong_dirs indice
  # corresponding to random num
  pong_ball_direction=$pong_dirs[$pong_rand_val]
}

# move cursor to specified x y vals
pong_move_cursor() {
  [ -z "$pcm_x" ] && {
    pcm_x="$1"
  }
  [ -z "$pcm_y" ] && {
    pcm_y="$2"
  }
  ([ -z "$pcm_y" ] || [ -z "$pcm_x" ] || \
   ! [[ $pcm_y =~ ^[0-9]+$ ]] || ! [[ $pcm_x =~ ^[0-9]+$ ]] || \
   ((pcm_y<=0)) || ((pcm_x<=0))) && {
     print "Error: pcm received invalid input ($pcm_x $pcm_y)"
     return 1
  }
  # adjustments needed due to formatting and UTF-8 chars
  ((pcm_y=(pcm_y+1)))
  ((pcm_x=(pcm_x*2)))
  ((pcm_x=(pcm_x-1)))
  # apply
  print -Pn "\e[${pcm_y};${pcm_x}H"
  unset pcm_y
  unset pcm_x
}

# alias pong_move_cursor to pcm for brevity
alias pcm="pong_move_cursor"

# formatted print - set arena colour, print, reset ansi, and rehide cursor
pbl_print() {
  print -Pn "\033[4"$arena_bg"m"
  print -n "$@"
  print -Pn "\033[0m"
  print -Pn "\033[?25l"
}

# collision detection logic
pong_collision_detection() {
    local x_test
    local y_test
    local ball_dir_change=0
    local pong_is_paddle=0
    case $pong_ball_direction in
      (ne) ((x_test=(ball_x_pos+1))) && ((y_test=(ball_y_pos-1))) ;;
      (e)  ((x_test=(ball_x_pos+1))) && ((y_test=ball_y_pos)) ;;
      (se) ((x_test=(ball_x_pos+1))) && ((y_test=(ball_y_pos+1))) ;;
      (nw) ((x_test=(ball_x_pos-1))) && ((y_test=(ball_y_pos-1))) ;;
      (w)  ((x_test=(ball_x_pos-1))) && ((y_test=ball_y_pos)) ;;
      (sw) ((x_test=(ball_x_pos-1))) && ((y_test=(ball_y_pos+1))) ;;
    esac
    # if collision detected, set dir switch flag
    ((x_test<=0)) || ((x_test>arena_x)) || \
    ((y_test<=0)) || ((y_test>arena_y)) && {
      ((ball_dir_change++))
    }
    # if collision is paddle, set dir switch + paddle flags
    ((((x_test==left_pad_x)) && ((y_test==left_pad_y))) || \
    (((x_test==right_pad_x)) && ((y_test==right_pad_y))))  && {
      ((ball_dir_change++))
      ((pong_is_paddle++))
    }
  # do dir change if collision detected
  ((ball_dir_change==1)) && {
    ((pong_is_paddle==1)) && {
      ((ball_rand_val=((RANDOM%9)+1)))
    }
    ! [ -z "$ball_true_direction" ] && {
      pong_ball_direction=$ball_true_direction
    }
    case $pong_ball_direction in
      (nw) { ((pong_is_paddle==1)) && ((ball_was_east!=1)) && {
               ((ball_rand_val>=7)) && {
                 pong_ball_direction="e"
               } || {
                 pong_ball_direction="ne"
               }
             } || {
               pong_ball_direction="sw"
             }
             ((ball_was_east=0))
           } ;;
      (w) { ([ -z "$pong_w_last" ] || \
             ((pong_w_last==0))) && {
              ((pong_w_last=1))
              pong_ball_direction="ne"
            } || {
              ((pong_w_last=0))
              pong_ball_direction="se"
            }
          } ;;
      (sw) { ((pong_is_paddle==1)) && ((ball_was_east!=1)) && {
               ((ball_rand_val>=7)) && {
                 pong_ball_direction="e"
               } || {
                 pong_ball_direction="se"
               }
             } || {
               pong_ball_direction="nw"
             }
             ((ball_was_east=0))
           } ;;
      (ne) { ((pong_is_paddle==1)) && ((ball_was_west!=1)) && {
               ((ball_rand_val>=7)) && {
                 pong_ball_direction="w"
               } || {
                 pong_ball_direction="nw"
               }
             } || {
               pong_ball_direction="se"
             }
             ((ball_was_west=0))
           } ;;
      (e) { ([ -z "$pong_e_last" ] || \
             ((pong_e_last==0))) && {
              ((pong_e_last=1))
              pong_ball_direction="nw"
            } || {
              ((pong_e_last=0))
              pong_ball_direction="sw"
            }
          } ;;
      (se) { ((pong_is_paddle==1)) && ((ball_was_west!=1)) && {
               ((ball_rand_val>=7)) && {
                 pong_ball_direction="w"
               } || {
                 pong_ball_direction="sw"
               }
             } || {
               pong_ball_direction="ne"
             }
             ((ball_was_west=0))
           } ;;
    esac
  }
}

## main

# step 1 (pre-loop): init tasks, clear, and draw grid
pong_init_arena
pong_rand_dir

clear

pong_draw

# game loop
while true; do
  # step 2: detect point score
  ((ball_x_pos==1)) && {
    ((pong_score_right++))
    pong_init_arena
    pong_rand_dir
    pong_draw
  }
  ((ball_x_pos==arena_x)) && {
    ((pong_score_left++))
    pong_init_arena
    pong_rand_dir
    pong_draw
  }
  unset ball_true_direction
  # ensure we dont bounce east or west too often
  [ $pong_ball_direction = "e" ] && {
    ((ball_was_east=1))
  } || {
    ((ball_was_east=0))
  }
  [ $pong_ball_direction = "w" ] && {
    ((ball_was_west=1))
  } || {
    ((ball_was_west=0))
  }
  # step 3: paddle movement handler
  IFS= noglob read -r -s -t0.1 -k1 -d'' -u0 pong_mov_char
    # if no char in buffer, set buffer to NULL (case doesnt like empty vars)
    [ -z "$pong_mov_char" ] && pong_mov_char='NULL'
    case $pong_mov_char in
      (w) { ! [[ -z "$pong[$left_pad_x,$((left_pad_y-1))]" ]] && {
              pong[$left_pad_x,$left_pad_y]="$arena_tile"
              ((left_pad_y--))
              pong[$left_pad_x,$left_pad_y]="$l_pad_tile"
              pcm "$left_pad_x" "$((left_pad_y+1))"
              pbl_print "$arena_tile"
              pcm "$left_pad_x" "$left_pad_y"
              pbl_print "$l_pad_tile"
            }
          } ;;
      (s) { ! [[ -z "$pong[$left_pad_x,$((left_pad_y+1))]" ]] && {
              pong[$left_pad_x,$left_pad_y]="$arena_tile"
              ((left_pad_y++))
              pong[$left_pad_x,$left_pad_y]="$l_pad_tile"
              pcm "$left_pad_x" "$((left_pad_y-1))"
              pbl_print "$arena_tile"
              pcm "$left_pad_x" "$left_pad_y"
              pbl_print "$l_pad_tile"
            }
          } ;;
      (i) { ! [[ -z "$pong[$right_pad_x,$((right_pad_y-1))]" ]] && {
              pong[$right_pad_x,$right_pad_y]="$arena_tile"
              ((right_pad_y--))
              pong[$right_pad_x,$right_pad_y]="$r_pad_tile"
              pcm "$right_pad_x" "$((right_pad_y+1))"
              pbl_print "$arena_tile"
              pcm "$right_pad_x" "$right_pad_y"
              pbl_print "$r_pad_tile"
            }
          } ;;
      (k) { ! [[ -z "$pong[$right_pad_x,$((right_pad_y+1))]" ]] && {
              pong[$right_pad_x,$right_pad_y]="$arena_tile"
              ((right_pad_y++))
              pong[$right_pad_x,$right_pad_y]="$r_pad_tile"
              pcm "$right_pad_x" "$((right_pad_y-1))"
              pbl_print "$arena_tile"
              pcm "$right_pad_x" "$right_pad_y"
              pbl_print "$r_pad_tile"
            }
          } ;;
      (y) { $0
            return $?
          } ;;
      (b) { clear
            print "        "$(print -n "\033[1m")" "$(ctext white)"Final Score"
            print "         "$(ctext green)"-----------"
            [ "$pong_score_left" -gt "$pong_score_right" ] && {
              print "           "$(ctext cyan)"p1"$(ctext white)": "$(ctext yellow)""$pong_score_left""
              print "           "$(ctext red)"p2"$(ctext white)": "$pong_score_right""
              print ''
              print "          "$(ctext yellow)"Winner"$(ctext white)": "$(ctext cyan)"p1"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            } || [ "$pong_score_right" -gt "$pong_score_left" ] && {
              print "           "$(ctext red)"p2"$(ctext white)": "$(ctext yellow)""$pong_score_right""
              print "           "$(ctext cyan)"p1"$(ctext white)": "$pong_score_left""
              print ""
              print "          "$(ctext yellow)"Winner"$(ctext white)": "$(ctext red)"p2"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            } || {
              print "           "$(ctext cyan)"p1"$(ctext white)": "$pong_score_left""
              print "           "$(ctext red)"p2"$(ctext white)": "$pong_score_right""
              print ""
              print "            "$(ctext blue)"Tie"$(ctext white)"!"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            }
          } ;;
    esac
    unset pong_mov_char
  # step 4: check ball dir, query next indice to check for collision.
  # if collision detected, change dir
  # we must run pong_collision_detection at least twice to account for literal edge cases
  (((ball_x_pos==3)) || ((ball_x_pos==(arena_x-2)))) && {
    pong_collision_detection
    # handle middle bounce with angular direction
    ((ball_x_pos==3)) && {
      [ "$pong_ball_direction" != "w" ] && {
        ball_true_direction=$pong_ball_direction
        pong_ball_direction="w"
        pong_collision_detection
        [ "$pong_ball_direction" = "w" ] && {
          pong_ball_direction=$ball_true_direction
        }
      }
    }
    ((ball_x_pos==(arena_x-2))) && {
      [ "$pong_ball_direction" != "e" ] && {
        ball_true_direction=$pong_ball_direction
        pong_ball_direction="e"
        pong_collision_detection
        [ "$pong_ball_direction" = "e" ] && {
          pong_ball_direction=$ball_true_direction
        }
      }
    }
    unset ball_true_direction
  }
  (((ball_y_pos==1)) || ((ball_y_pos==arena_y))) && {
    pong_collision_detection
  }
  # step 5: update array to display ball movement
  ball_old_x="$ball_x_pos"
  ball_old_y="$ball_y_pos"
  case $pong_ball_direction in
    (ne) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos++))
           ((ball_y_pos--))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (e)  { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos++))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (se) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos++))
           ((ball_y_pos++))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (nw) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos--))
           ((ball_y_pos--))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (w)  { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos--))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (sw) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ((ball_x_pos--))
           ((ball_y_pos++))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
  esac
  pcm "$ball_old_x" "$ball_old_y"
  pbl_print "$arena_tile"
  pcm "$ball_x_pos" "$ball_y_pos"
  pbl_print "$ball_tile"
done
print "\033[?25h"
unset pong
stty echo
