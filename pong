#!/usr/bin/env zsh

## env setup

# load mathfunc for rint
zmodload zsh/mathfunc

# for fancy scoreboard print
source libfancytext

# associative array for game arena (hashmap)
typeset -A pong

# alias integer to int for brevity
alias int=integer

# clear screen, hide cursor, set echo chars to false
clear
print "\033[?25l"
stty -echo
print "Loading..."

# define ints for scorekeeping
int pong_score_left pong_score_right

[ -z "$arena_tile" ] && {
  arena_tile='ğŸŸ¦'
}

[ -z "$ball_tile" ] && {
  ball_tile='ğŸ¸'
}

[ -z "$l_pad_tile" ] && {
  l_pad_tile='ğŸªµ'
}

[ -z "$r_pad_tile" ] && {
  r_pad_tile='ğŸ€'
}

[ -z "$arena_x" ] && {
  int arena_x=17
}

[ -z "$arena_y" ] && {
  int arena_y=9
}

[ -z "$arena_bg" ] || \
! [[ $arena_bg =~ ^[0-7]+$ ]] && {
  int arena_bg=4
}

int arena_x_mid arena_y_mid paddletwo_start_x paddleone_start_x
((arena_x_mid=(arena_x-(arena_x/2))))
((arena_y_mid=(arena_y-(arena_y/2))))
((paddleone_start_x=2))
((paddletwo_start_x=(arena_x-1)))

## helper functions

# populate gameboard, set starting positions
pong_init_arena() {
  for ((y_total=1; y_total<=arena_y; y_total++)); do
    for ((x_total=1; x_total<=arena_x; x_total++)); do
      pong[$x_total,$y_total]="$arena_tile"
    done
  done
  pong[$arena_x_mid,$arena_y_mid]="$ball_tile"
  pong[$paddleone_start_x,$arena_y_mid]="$l_pad_tile"
  pong[$paddletwo_start_x,$arena_y_mid]="$r_pad_tile"
  ball_x_pos="$arena_x_mid"
  ball_y_pos="$arena_y_mid"
  # generate random num between 1-9
  randonum=$(((RANDOM%9)+1))
  # if 1 2 or 3, shift start pos north
  ((randonum<=3)) && {
    pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
    ((ball_y_pos++))
    # generate random num between 0-9
    randonum2=$((RANDOM%10))
    # if greater than 4, shift again (50%)
    ((randonum2>4)) && {
      ((ball_y_pos++))
    }
    # generate random num between 0-9
    randonum3=$((RANDOM%10))
    # if greater than 7, shift again (20%)
    ((randonum3>7)) && {
      ((ball_y_pos++))
    }
    pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
  }
  # if 4 5 or 6, do nothing
  # if 7 8 or 9, shift start pos south
  ((randonum>6)) && {
    pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
    ((ball_y_pos--))
    # generate random num between 0-9
    randonum2=$((RANDOM%10))
    # if greater than 4, shift again (50/50)
    ((randonum2>4)) && {
      ((ball_y_pos--))
    }
    # generate random num between 0-9
    randonum3=$((RANDOM%10))
    # if greater than 7, shift again (20%)
    ((randonum3>7)) && {
      ((ball_y_pos--))
    }
    pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
  }
  left_pad_x="$paddleone_start_x"
  left_pad_y="$arena_y_mid"
  right_pad_x="$paddletwo_start_x"
  right_pad_y="$arena_y_mid"
}

print_pong_arr() {
  for ((y_count=1; y_count<=y_total; y_count++)); do
    x_count=0
    for ((x_count=1; x_count<=x_total; x_count++)); do
      print -n $pong[$x_count,$y_count]
    done
    print
  done
}

pong_draw() {
  pong_buffer=$(print_pong_arr)
  print "\033[4"$arena_bg"m"
  print "\033[H"
  print "$pong_buffer"
  print "\033[0m"
  print "\033[?25l"
  print "\033[F"$(ctext cyan)"p1 score"$(ctext white)": "$pong_score_left"           "$(ctext red)"p2 score"$(ctext white)": "$pong_score_right""$(ctext reset)""
  print ''
}

pong_rand_dir() {
  pong_dirs=('ne'
             'e'
             'se'
             'sw'
             'w'
             'nw')
  ((pong_rand_val=((RANDOM%6)+1)))
  pong_ball_direction=$pong_dirs[$pong_rand_val]
}

pong_move_cursor() {
  [ -z "$pcm_x" ] && {
    pcm_x="$1"
  }
  [ -z "$pcm_y" ] && {
    pcm_y="$2"
  }
  ([ -z "$pcm_y" ] || [ -z "$pcm_x" ] || \
   ! [[ $pcm_y =~ ^[0-9]+$ ]] || ! [[ $pcm_x =~ ^[0-9]+$ ]] || \
   [ "$pcm_y" -le 0 ] || [ "$pcm_x" -le 0 ]) && {
     print "Error: pcm received invalid input ($pcm_x $pcm_y)"
     return 1
  }
  # adjustments needed due to formatting and UTF-8 chars
  ((pcm_y=(pcm_y+1)))
  ((pcm_x=(pcm_x*2)))
  ((pcm_x=(pcm_x-1)))
  # apply
  print -Pn "\e[${pcm_y};${pcm_x}H"
  unset pcm_y
  unset pcm_x
}

alias pcm="pong_move_cursor"

pbl_print() {
  print -Pn "\033[4"$arena_bg"m"
  print -n "$@"
  print -Pn "\033[0m"
  print -Pn "\033[?25l"
}

## main

pong_init_arena
pong_rand_dir

clear
# step 1 - draw arena
pong_draw

while true; do
  # step 2: detect point score
  [ "$ball_x_pos" = 1 ] && {
    pong_score_right=$((pong_score_right+1))
    pong_init_arena
    pong_rand_dir
    pong_draw
  }
  [ "$ball_x_pos" = $arena_x ] && {
    pong_score_left=$((pong_score_left+1))
    pong_init_arena
    pong_rand_dir
    pong_draw
  }
  unset ball_true_direction
  [ $pong_ball_direction = "e" ] && {
    ball_was_east=1
  } || {
    ball_was_east=0
  }
  [ $pong_ball_direction = "w" ] && {
    ball_was_west=1
  } || {
    ball_was_west=0
  }
  # step 3: paddle movement handler
  IFS= noglob read -r -s -t0.1 -k1 -d'' -u0 pong_mov_char
    [ -z "$pong_mov_char" ] && pong_mov_char='NULL'
    case $pong_mov_char in
      (w) { ! [[ -z "$pong[$left_pad_x,$((left_pad_y-1))]" ]] && {
              pong[$left_pad_x,$left_pad_y]="$arena_tile"
              left_pad_y=$((left_pad_y-1))
              pong[$left_pad_x,$left_pad_y]="$l_pad_tile"
              pcm "$left_pad_x" "$((left_pad_y+1))"
              pbl_print "$arena_tile"
              pcm "$left_pad_x" "$left_pad_y"
              pbl_print "$l_pad_tile"
            }
          } ;;
      (s) { ! [[ -z "$pong[$left_pad_x,$((left_pad_y+1))]" ]] && {
              pong[$left_pad_x,$left_pad_y]="$arena_tile"
              left_pad_y=$((left_pad_y+1))
              pong[$left_pad_x,$left_pad_y]="$l_pad_tile"
              pcm "$left_pad_x" "$((left_pad_y-1))"
              pbl_print "$arena_tile"
              pcm "$left_pad_x" "$left_pad_y"
              pbl_print "$l_pad_tile"
            }
          } ;;
      (i) { ! [[ -z "$pong[$right_pad_x,$((right_pad_y-1))]" ]] && {
              pong[$right_pad_x,$right_pad_y]="$arena_tile"
              right_pad_y=$((right_pad_y-1))
              pong[$right_pad_x,$right_pad_y]="$r_pad_tile"
              pcm "$right_pad_x" "$((right_pad_y+1))"
              pbl_print "$arena_tile"
              pcm "$right_pad_x" "$right_pad_y"
              pbl_print "$r_pad_tile"
            }
          } ;;
      (k) { ! [[ -z "$pong[$right_pad_x,$((right_pad_y+1))]" ]] && {
              pong[$right_pad_x,$right_pad_y]="$arena_tile"
              right_pad_y=$((right_pad_y+1))
              pong[$right_pad_x,$right_pad_y]="$r_pad_tile"
              pcm "$right_pad_x" "$((right_pad_y-1))"
              pbl_print "$arena_tile"
              pcm "$right_pad_x" "$right_pad_y"
              pbl_print "$r_pad_tile"
            }
          } ;;
      (y) { $0
            return $?
          } ;;
      (b) { clear
            print "        "$(print -n "\033[1m")" "$(ctext white)"Final Score"
            print "         "$(ctext green)"-----------"
            [ "$pong_score_left" -gt "$pong_score_right" ] && {
              print "           "$(ctext cyan)"p1"$(ctext white)": "$(ctext yellow)""$pong_score_left""
              print "           "$(ctext red)"p2"$(ctext white)": "$pong_score_right""
              print ''
              print "          "$(ctext yellow)"Winner"$(ctext white)": "$(ctext cyan)"p1"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            } || [ "$pong_score_right" -gt "$pong_score_left" ] && {
              print "           "$(ctext red)"p2"$(ctext white)": "$(ctext yellow)""$pong_score_right""
              print "           "$(ctext cyan)"p1"$(ctext white)": "$pong_score_left""
              print ""
              print "          "$(ctext yellow)"Winner"$(ctext white)": "$(ctext red)"p2"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            } || {
              print "           "$(ctext cyan)"p1"$(ctext white)": "$pong_score_left""
              print "           "$(ctext red)"p2"$(ctext white)": "$pong_score_right""
              print ""
              print "            "$(ctext blue)"Tie"$(ctext white)"!"$(ctext reset)""
              print ''
              print "\033[?25h"
              unset pong
              return 0
            }
          } ;;
    esac
    unset pong_mov_char
  # step 4: check ball dir, query next indice to check for collision
  pong_collision_detection() {
      case $pong_ball_direction in
        (ne) ball_pos_check=${pong[$((ball_x_pos+1)),$((ball_y_pos-1))]:-OOB} ;;
        (e)  ball_pos_check=${pong[$((ball_x_pos+1)),$ball_y_pos]:-OOB} ;;
        (se) ball_pos_check=${pong[$((ball_x_pos+1)),$((ball_y_pos+1))]:-OOB} ;;
        (nw) ball_pos_check=${pong[$((ball_x_pos-1)),$((ball_y_pos-1))]:-OOB} ;;
        (w)  ball_pos_check=${pong[$((ball_x_pos-1)),$ball_y_pos]:-OOB} ;;
        (sw) ball_pos_check=${pong[$((ball_x_pos-1)),$((ball_y_pos+1))]:-OOB}
      esac
      # step 5: if collision detected, set dir switch flag
      pong_is_paddle=0
      case $ball_pos_check in
        (OOB) ball_dir_change=1 ;;
        ($l_pad_tile)  { ball_dir_change=1
               pong_is_paddle=1 } ;;
        ($r_pad_tile)  { ball_dir_change=1
               pong_is_paddle=1 } ;;
        (*)   ball_dir_change=0 ;;
      esac
    # step 6: do dir change if collision detected
    [ "$ball_dir_change" = 1 ] && {
      [ "$pong_is_paddle" = 1 ] && {
        ball_rand_val=$(((RANDOM%9)+1))
      }
      ! [ -z "$ball_true_direction" ] && {
        pong_ball_direction=$ball_true_direction
      }
      case $pong_ball_direction in
        (nw) { [ "$pong_is_paddle" = 1 ] && [ "$ball_was_east" != 1 ] && {
                 [ "$ball_rand_val" -ge 7 ] && {
                   pong_ball_direction="e"
                 } || {
                   pong_ball_direction="ne"
                 }
               } || {
                 pong_ball_direction="sw"
               }
               ball_was_east=0
             } ;;
        (w) { ([ -z "$pong_w_last" ] || \
               [ "$pong_w_last" = "0" ]) && {
                pong_w_last=1
                pong_ball_direction="ne"
              } || {
                pong_w_last=0
                pong_ball_direction="se"
              }
            } ;;
        (sw) { [ "$pong_is_paddle" = 1 ] && [ "$ball_was_east" != 1 ] && {
                 [ "$ball_rand_val" -ge 7 ] && {
                   pong_ball_direction="e"
                 } || {
                   pong_ball_direction="se"
                 }
               } || {
                 pong_ball_direction="nw"
               }
               ball_was_east=0
             } ;;
        (ne) { [ "$pong_is_paddle" = 1 ] && [ "$ball_was_west" != 1 ] && {
                 [ "$ball_rand_val" -ge 7 ] && {
                   pong_ball_direction="w"
                 } || {
                   pong_ball_direction="nw"
                 }
               } || {
                 pong_ball_direction="se"
               }
               ball_was_west=0
             } ;;
        (e) { ([ -z "$pong_e_last" ] || \
               [ "$pong_e_last" = 0 ]) && {
                pong_e_last=1
                pong_ball_direction="nw"
              } || {
                pong_e_last=0
                pong_ball_direction="sw"
              }
            } ;;
        (se) { [ "$pong_is_paddle" = 1 ] && [ "$ball_was_west" != 1 ] && {
                 [ "$ball_rand_val" -ge 7 ] && {
                   pong_ball_direction="w"
                 } || {
                   pong_ball_direction="sw"
                 }
               } || {
                 pong_ball_direction="ne"
               }
               ball_was_west=0
             } ;;
      esac
    }
  }
  # we must run the above twice to account for literal edge cases
  ([ "$ball_x_pos" -eq "3" ] || [ "$ball_x_pos" -eq "$((arena_x-2))" ]) && {
    pong_collision_detection
    # handle middle bounce with angular direction
    [ "$ball_x_pos" -eq "3" ] && {
      [ "$pong_ball_direction" != "w" ] && {
        ball_true_direction=$pong_ball_direction
        pong_ball_direction="w"
        pong_collision_detection
        [ "$pong_ball_direction" = "w" ] && {
          pong_ball_direction=$ball_true_direction
        }
      }
    }
    [ "$ball_x_pos" -eq "$((arena_x-2))" ] && {
      [ "$pong_ball_direction" != "e" ] && {
        ball_true_direction=$pong_ball_direction
        pong_ball_direction="e"
        pong_collision_detection
        [ "$pong_ball_direction" = "e" ] && {
          pong_ball_direction=$ball_true_direction
        }
      }
    }
    unset ball_true_direction
  }
  ([ "$ball_y_pos" -eq "1" ] || [ "$ball_y_pos" -eq "$arena_y" ]) && {
    pong_collision_detection
  }
  # step 7: update array to display ball movement
  ball_old_x="$ball_x_pos"
  ball_old_y="$ball_y_pos"
  case $pong_ball_direction in
    (ne) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos+1))
           ball_y_pos=$((ball_y_pos-1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (e)  { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos+1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (se) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos+1))
           ball_y_pos=$((ball_y_pos+1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (nw) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos-1))
           ball_y_pos=$((ball_y_pos-1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (w)  { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos-1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
    (sw) { pong[$ball_x_pos,$ball_y_pos]="$arena_tile"
           ball_x_pos=$((ball_x_pos-1))
           ball_y_pos=$((ball_y_pos+1))
           pong[$ball_x_pos,$ball_y_pos]="$ball_tile"
         } ;;
  esac
  pcm "$ball_old_x" "$ball_old_y"
  pbl_print "$arena_tile"
  pcm "$ball_x_pos" "$ball_y_pos"
  pbl_print "$ball_tile"
done
print "\033[?25h"
unset pong
stty echo
